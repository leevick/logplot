#!/usr/bin/env python3
"""Generic XY plotter for logs.

Parses generic log lines of the form:
    [label] X Y  (values can be hex: 0xABCD, integers: -1, +1, 0, or floats: -0.1, +0.1, 0.0)
    [label] xy X Y  (draws crossing vertical and horizontal lines at X and Y)
and marker lines with subplot support:
    [label] x X             - vertical line in default subplot
    <x1>[label] x X         - vertical line in x1 column, default row
    <x1>[label]<y1> x X     - vertical line in specific x1,y1 subplot
    <x1>[label]<> x X       - vertical line across all subplots in x1 column
    
    Similar syntax for horizontal lines (y) and crosshairs (xy)
    
Value formats supported:
    - Hexadecimal: 0xabcd, 0x00abcd (case-insensitive)
    - Signed integers: 0, -1, +1
    - Signed floats: 0.0, -0.1, +0.1, -0.0, +0.0

Supports subplot organization using optional tags:
    <x_label>[label1][label2]<y_label> 0xX 0xY1 0xY2
    
Where <x_label> and <y_label> determine subplot placement:
    - Each unique x_label gets its own column
    - Each unique y_label gets its own row
    - Omitted labels default to empty string (column 0 / row 0)
    - Empty angle brackets <> act as wildcard (apply to all subplots in that dimension)

It groups step pairs by `label` and plots X on the horizontal axis and Y on the vertical axis.


Usage: logplot /path/to/logfile
"""
import re
import os
import sys
import argparse
from pathlib import Path

try:
    import matplotlib.pyplot as plt
    import numpy as np
except Exception as e:
    print("matplotlib and numpy are required: pip install matplotlib numpy", file=sys.stderr)
    raise


# Number pattern: supports hex (0xABCD), signed integers (+1, -1, 0), and floats (+0.1, -0.1, 0.0)
# IMPORTANT: hex alternative must come first so "0x..." is not consumed as plain integer "0"
NUM_PATTERN = r"(?:0x[0-9A-Fa-f]+|[+-]?(?:\d+\.\d+|\d+))"

def parse_value(val_str):
    """Parse a value string that can be hex, integer, or float.
    
    Supports:
    - Hexadecimal: 0xabcd, 0x00abcd
    - Integers: 0, -1, +1
    - Floats: 0.0, -0.1, +0.1
    """
    val_str = val_str.strip()
    
    # Check for hexadecimal
    if val_str.startswith('0x') or val_str.startswith('0X'):
        return int(val_str, 16)
    
    # Check for float (contains decimal point)
    if '.' in val_str:
        return float(val_str)
    
    # Integer
    return int(val_str)


MARKER_RE = re.compile(rf"\[A\]\s+MARK\s+({NUM_PATTERN})")

# Generic patterns with optional subplot tags:
# Supports: <x_label>[label]<y_label> x/y/xy value
# Use <> for wildcard (apply to all subplots in that dimension)
VERTICAL_RE = re.compile(rf"(?:<(?P<xlabel>[A-Za-z0-9_]*)>)?\[(?P<label>[A-Za-z0-9_]+)\](?:<(?P<ylabel>[A-Za-z0-9_]*)>)?\s*x\s*(?P<val>{NUM_PATTERN})")
HORIZONTAL_RE = re.compile(rf"(?:<(?P<xlabel>[A-Za-z0-9_]*)>)?\[(?P<label>[A-Za-z0-9_]+)\](?:<(?P<ylabel>[A-Za-z0-9_]*)>)?\s*y\s*(?P<val>{NUM_PATTERN})")
XY_RE = re.compile(rf"(?:<(?P<xlabel>[A-Za-z0-9_]*)>)?\[(?P<label>[A-Za-z0-9_]+)\](?:<(?P<ylabel>[A-Za-z0-9_]*)>)?\s+xy\s+(?P<x>{NUM_PATTERN})\s+(?P<y>{NUM_PATTERN})")
STEP_RE = re.compile(rf"\[(?P<label>[A-Za-z0-9_]+)\]\s+(?P<x>{NUM_PATTERN})\s+(?P<y>{NUM_PATTERN})")


def extract_subplot_labels(match, line):
    """Extract x and y labels from regex match, converting <> to wildcard '*'."""
    x_label = match.group('xlabel') if match.group('xlabel') is not None else None
    y_label = match.group('ylabel') if match.group('ylabel') is not None else None
    
    # Check if angle brackets were present with empty content (wildcard <>)
    if x_label is not None and x_label == '':
        # Check if there's a <> before the [label]
        if re.search(r'<>\s*\[', line):
            x_label = '*'
            
    if y_label is not None and y_label == '':
        # Check if there's a <> after the [label]
        if re.search(r'\]\s*<>\s*(x|y|xy)', line):
            y_label = '*'
    
    # Convert None to empty string for default subplot
    x_label = x_label if x_label is not None else ''
    y_label = y_label if y_label is not None else ''
    
    return (x_label, y_label)


def parse_log(path):
    # Collect parsed generic items
    # step_series: { (x_label, y_label): { series_label: [(x, y), ...] } }
    step_series = {}
    # For markers, use special '*' to indicate "apply to all"
    vertical_lines = {}    # { (x_label, y_label): [(x, label), ...] } where label can be '*' for wildcard
    horizontal_lines = {}  # { (x_label, y_label): [(y, label), ...] }
    xy_crosshairs = {}     # { (x_label, y_label): [(x, y, label), ...] }
    markers = {}

    with open(path, 'r', errors='ignore') as f:
        for line in f:
            # Generic marker lines (always in default subplot)
            mm = MARKER_RE.search(line)
            if mm:
                marker_s = mm.group(1)
                # Skip sentinel hex values
                if marker_s.lower() not in {"0xffffffff", "0xffffffffffffffff"}:
                    try:
                        marker_val = parse_value(marker_s)
                        subplot_key = ('', '')
                        markers.setdefault(subplot_key, []).append(marker_val)
                    except ValueError:
                        pass
                continue

            # Vertical single-value entries with subplot tags: <x_label>[label]<y_label> x VALUE
            vm = VERTICAL_RE.search(line)
            if vm:
                lbl = vm.group('label')
                val_s = vm.group('val')
                subplot_key = extract_subplot_labels(vm, line)
                # Skip sentinel hex values
                if val_s.lower() not in {"0xffffffff", "0xffffffffffffffff"}:
                    try:
                        v_val = parse_value(val_s)
                        vertical_lines.setdefault(subplot_key, []).append((v_val, lbl))
                    except ValueError:
                        pass
                continue

            # Horizontal single-value entries with subplot tags: <x_label>[label]<y_label> y VALUE
            hm = HORIZONTAL_RE.search(line)
            if hm:
                lbl = hm.group('label')
                val_s = hm.group('val')
                subplot_key = extract_subplot_labels(hm, line)
                # Skip sentinel hex values
                if val_s.lower() not in {"0xffffffff", "0xffffffffffffffff"}:
                    try:
                        v_val = parse_value(val_s)
                        horizontal_lines.setdefault(subplot_key, []).append((v_val, lbl))
                    except ValueError:
                        pass
                continue

            # XY point entries with subplot tags: <x_label>[label]<y_label> xy X Y
            xym = XY_RE.search(line)
            if xym:
                lbl = xym.group('label')
                x_s = xym.group('x')
                y_s = xym.group('y')
                subplot_key = extract_subplot_labels(xym, line)
                # Skip sentinel hex values
                if x_s.lower() in {"0xffffffff", "0xffffffffffffffff"} or y_s.lower() in {"0xffffffffffffffff"}:
                    continue
                try:
                    x_val = parse_value(x_s)
                    y_val = parse_value(y_s)
                    xy_crosshairs.setdefault(subplot_key, []).append((x_val, y_val, lbl))
                except ValueError:
                    pass
                continue

            # Multi-label lines with optional subplot tags: <x_label>[lbl1][lbl2]<y_label> X Y1 Y2 ...
            # Pattern: optional <x_label>, one or more [label], optional <y_label>, then values
            ml_match = re.match(rf'(?:<(?P<xlabel>[A-Za-z0-9_]+)>)?((?:\[[A-Za-z0-9_]+\])+)(?:<(?P<ylabel>[A-Za-z0-9_]+)>)?(?:\s+{NUM_PATTERN})+', line)
            if ml_match:
                x_label = ml_match.group('xlabel') or ''  # default subplot
                y_label = ml_match.group('ylabel') or ''  # default subplot
                subplot_key = (x_label, y_label)
                
                labels = re.findall(r'\[([A-Za-z0-9_]+)\]', ml_match.group(2))
                values = re.findall(NUM_PATTERN, line)
                if len(values) >= 2 and labels:
                    x_s = values[0]
                    ys_s = values[1:]
                    sentinels = {"0xffffffff", "0xffffffffffffffff"}
                    count = min(len(labels), len(ys_s))
                    for i in range(count):
                        lbl = labels[i]
                        y_s = ys_s[i]
                        if x_s.lower() in sentinels or y_s.lower() in sentinels:
                            continue
                        try:
                            x_val = parse_value(x_s)
                            y_val = parse_value(y_s)
                            if subplot_key not in step_series:
                                step_series[subplot_key] = {}
                            step_series[subplot_key].setdefault(lbl, []).append((x_val, y_val))
                        except ValueError:
                            continue
                    continue

            # Step-style entries: [label] X Y (default subplot)
            sm = STEP_RE.search(line)
            if sm:
                lbl = sm.group('label')
                x_s = sm.group('x')
                y_s = sm.group('y')
                # Skip sentinel hex values
                if x_s.lower() in {"0xffffffff", "0xffffffffffffffff"} or y_s.lower() in {"0xffffffffffffffff"}:
                    continue
                try:
                    x_val = parse_value(x_s)
                    y_val = parse_value(y_s)
                    subplot_key = ('', '')
                    if subplot_key not in step_series:
                        step_series[subplot_key] = {}
                    step_series[subplot_key].setdefault(lbl, []).append((x_val, y_val))
                except ValueError:
                    pass
                continue

    return {
        'step_series': step_series,
        'vertical_lines': vertical_lines,
        'horizontal_lines': horizontal_lines,
        'xy_crosshairs': xy_crosshairs,
        'markers': markers,
    }


def plot_histograms(data, out_file=None, show=True):
    """Plot normalized histograms of Y values for each subplot.
    
    Histograms are drawn as curves (line plots) with normalized heights summing to 1.
    Each label gets its own curve with consistent colors from the main plot.
    """
    step_series = data.get('step_series', {})

    # Determine unique x and y labels to create subplot grid (exclude wildcards)
    all_keys = set(step_series.keys())
    grid_keys = {k for k in all_keys if '*' not in k}
    
    if not grid_keys:
        print("No data to plot")
        return
    
    all_x_labels = sorted(set(k[0] for k in grid_keys))
    all_y_labels = sorted(set(k[1] for k in grid_keys))
    
    # Filter out rows and columns that have no data
    rows_with_data = set()
    cols_with_data = set()
    
    for (x_label, y_label), series_data in step_series.items():
        if '*' in (x_label, y_label):
            continue
        if series_data:
            rows_with_data.add(y_label)
            cols_with_data.add(x_label)
    
    x_labels = [lbl for lbl in all_x_labels if lbl in cols_with_data]
    y_labels = [lbl for lbl in all_y_labels if lbl in rows_with_data]
    
    if not x_labels or not y_labels:
        print("No data to plot")
        return
    
    x_label_to_col = {lbl: i for i, lbl in enumerate(x_labels)}
    y_label_to_row = {lbl: i for i, lbl in enumerate(y_labels)}
    
    n_rows = len(y_labels)
    n_cols = len(x_labels)
    
    # Create subplot grid
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(6 * n_cols, 5 * n_rows), squeeze=False)

    # Plot histogram for each subplot
    for x_label in x_labels:
        for y_label in y_labels:
            row = y_label_to_row[y_label]
            col = x_label_to_col[x_label]
            ax = axes[row][col]
            
            # Get data for this specific subplot
            subplot_step_series = step_series.get((x_label, y_label), {})
            
            if not subplot_step_series:
                continue
            
            # Use same color scheme as main plot
            colors = plt.rcParams['axes.prop_cycle'].by_key().get('color', [])
            idx = 0
            
            for lbl, points in subplot_step_series.items():
                # Extract Y values only
                y_vals = [p[1] for p in points]
                
                if not y_vals:
                    continue
                
                color = colors[idx % len(colors)] if colors else None
                
                # Compute histogram with automatic binning
                counts, bin_edges = np.histogram(y_vals, bins='auto')
                
                # Normalize to sum to 1 (probability distribution)
                counts_normalized = counts / counts.sum()
                
                # Use bin centers for plotting
                bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2
                
                # Plot as curve
                ax.plot(bin_centers, counts_normalized, color=color, label=lbl, linewidth=1.5)
                ax.fill_between(bin_centers, counts_normalized, alpha=0.2, color=color)
                
                idx += 1
            
            # Set subplot title
            title_parts = []
            if x_label:
                title_parts.append(f"x:{x_label}")
            if y_label:
                title_parts.append(f"y:{y_label}")
            if title_parts:
                ax.set_title(' '.join(title_parts))
            else:
                ax.set_title('default')
            
            ax.set_xlabel('Y Value')
            ax.set_ylabel('Normalized Frequency')
            ax.legend(fontsize=7)
            ax.grid(True, alpha=0.3)
    
    fig.tight_layout()

    if out_file:
        fig.savefig(out_file, bbox_inches='tight')
        print(f"Saved histogram plot to {out_file}")

    return fig


def plot_data(data, out_file=None, show=True, align_axes=True):
    step_series = data.get('step_series', {})
    markers = data.get('markers', {})
    vertical_lines = data.get('vertical_lines', {})
    horizontal_lines = data.get('horizontal_lines', {})
    xy_crosshairs = data.get('xy_crosshairs', {})

    # Determine unique x and y labels to create subplot grid (exclude wildcards)
    all_keys = set(step_series.keys())
    # Only include non-wildcard keys for grid determination
    grid_keys = {k for k in all_keys if '*' not in k}
    
    if not grid_keys:
        print("No data to plot")
        return
    
    all_x_labels = sorted(set(k[0] for k in grid_keys))
    all_y_labels = sorted(set(k[1] for k in grid_keys))
    
    # Filter out rows and columns that have no data
    # A row has data if any subplot in that row has data
    # A column has data if any subplot in that column has data
    rows_with_data = set()
    cols_with_data = set()
    
    for (x_label, y_label), series_data in step_series.items():
        if '*' in (x_label, y_label):
            continue
        if series_data:  # Only count if there's actual data
            rows_with_data.add(y_label)
            cols_with_data.add(x_label)
    
    # Also check for markers, lines, and crosshairs
    for data_dict in [markers, vertical_lines, horizontal_lines, xy_crosshairs]:
        for (x_label, y_label), items in data_dict.items():
            if '*' in (x_label, y_label):
                continue
            if items:  # Only count if there are items
                rows_with_data.add(y_label)
                cols_with_data.add(x_label)
    
    # Filter labels to only those with data
    x_labels = [lbl for lbl in all_x_labels if lbl in cols_with_data]
    y_labels = [lbl for lbl in all_y_labels if lbl in rows_with_data]
    
    if not x_labels or not y_labels:
        print("No data to plot")
        return
    
    # Create mapping from label to index
    x_label_to_col = {lbl: i for i, lbl in enumerate(x_labels)}
    y_label_to_row = {lbl: i for i, lbl in enumerate(y_labels)}
    
    n_rows = len(y_labels)
    n_cols = len(x_labels)
    
    # Helper function to expand wildcard keys
    def get_matching_subplots(subplot_key):
        """Returns list of actual subplot keys that match the given key (which may contain wildcards)."""
        x_key, y_key = subplot_key
        matching = []
        
        for x_label in x_labels:
            for y_label in y_labels:
                x_match = (x_key == '*' or x_key == x_label)
                y_match = (y_key == '*' or y_key == y_label)
                if x_match and y_match:
                    matching.append((x_label, y_label))
        
        return matching
    
    # Create subplot grid
    fig, axes = plt.subplots(n_rows, n_cols, figsize=(6 * n_cols, 5 * n_rows), squeeze=False)

    # Actual data extents collected during plotting: (row, col) -> (x_vals, y_vals)
    subplot_data_ranges = {}

    # Plot each subplot
    for x_label in x_labels:
        for y_label in y_labels:
            row = y_label_to_row[y_label]
            col = x_label_to_col[x_label]
            ax = axes[row][col]
            
            # Get data for this specific subplot
            subplot_step_series = step_series.get((x_label, y_label), {})
            
            # Collect markers from all matching wildcard patterns
            subplot_markers = []
            subplot_vertical_lines = []
            subplot_horizontal_lines = []
            subplot_xy_crosshairs = []
            
            # Check all marker keys to see if they apply to this subplot
            for marker_key, marker_list in markers.items():
                if (x_label, y_label) in get_matching_subplots(marker_key):
                    subplot_markers.extend(marker_list)
            
            for vline_key, vline_list in vertical_lines.items():
                if (x_label, y_label) in get_matching_subplots(vline_key):
                    subplot_vertical_lines.extend(vline_list)
            
            for hline_key, hline_list in horizontal_lines.items():
                if (x_label, y_label) in get_matching_subplots(hline_key):
                    subplot_horizontal_lines.extend(hline_list)
            
            for xy_key, xy_list in xy_crosshairs.items():
                if (x_label, y_label) in get_matching_subplots(xy_key):
                    subplot_xy_crosshairs.extend(xy_list)
            
            # Plot step series
            colors = plt.rcParams['axes.prop_cycle'].by_key().get('color', [])
            idx = 0
            any_x_vals = []
            any_y_vals = []
            
            for lbl, points in subplot_step_series.items():
                pts_x = [p[0] for p in points]
                pts_y = [p[1] for p in points]
                any_x_vals.extend(pts_x)
                any_y_vals.extend(pts_y)
                color = colors[idx % len(colors)] if colors else None
                ax.step(pts_x, pts_y, where='post', color=color, label=lbl)
                ax.scatter(pts_x, pts_y, marker='x', color=color, s=6, linewidths=0.6)
                idx += 1

            # Record actual data extents for this subplot (include all line/crosshair positions)
            all_x_for_range = list(any_x_vals) + [vx for vx, _lbl in subplot_vertical_lines] + [vx for vx, _hy, _lbl in subplot_xy_crosshairs]
            all_y_for_range = list(any_y_vals) + [hy for hy, _lbl in subplot_horizontal_lines] + [hy for _vx, hy, _lbl in subplot_xy_crosshairs]
            subplot_data_ranges[(row, col)] = (all_x_for_range, all_y_for_range)

            # Draw y = x diagonal if we have data
            if any_x_vals and any_y_vals:
                xmin = min(any_x_vals)
                xmax = max(any_x_vals)
                ymin = min(any_y_vals)
                ymax = max(any_y_vals)
                lo = min(xmin, ymin)
                hi = max(xmax, ymax)
                ax.plot([lo, hi], [lo, hi], linestyle='--', color='gray', linewidth=0.5, alpha=0.8, label='y = x')
            
            # Draw markers
            for marker in subplot_markers:
                ax.axvline(x=marker, linestyle='--', color='black', linewidth=0.4, alpha=0.6)
                ax.axhline(y=marker, linestyle='--', color='black', linewidth=0.4, alpha=0.6)
            
            # Draw vertical lines
            for vx, lbl in subplot_vertical_lines:
                ax.axvline(x=vx, linestyle='--', color='magenta', linewidth=0.4, alpha=0.6)
                ax.text(vx, 0.98, lbl, transform=ax.get_xaxis_transform(), rotation=90,
                        va='top', ha='right', color='magenta', fontsize=7)
            
            # Draw horizontal lines
            for hy, lbl in subplot_horizontal_lines:
                ax.axhline(y=hy, linestyle='--', color='cyan', linewidth=0.4, alpha=0.6)
                ax.text(0.02, hy, lbl, transform=ax.get_yaxis_transform(),
                        va='bottom', ha='left', color='cyan', fontsize=7)
            
            # Draw xy crosshairs
            for vx, hy, lbl in subplot_xy_crosshairs:
                ax.axvline(x=vx, linestyle='--', color='red', linewidth=0.6, alpha=0.7)
                ax.axhline(y=hy, linestyle='--', color='red', linewidth=0.6, alpha=0.7)
                ax.annotate(lbl, xy=(vx, hy), xytext=(5, 5), textcoords='offset points',
                           color='red', fontsize=8, fontweight='bold',
                           bbox=dict(boxstyle='round,pad=0.3', facecolor='yellow', alpha=0.7, edgecolor='red'))

            # Set subplot title showing x and y labels
            title_parts = []
            if x_label:
                title_parts.append(f"x:{x_label}")
            if y_label:
                title_parts.append(f"y:{y_label}")
            if title_parts:
                ax.set_title(' '.join(title_parts))
            else:
                ax.set_title('default')

            ax.legend(fontsize=7)
            ax.grid(True)
    
    # Align axes for subplots in same column/row if requested
    AXIS_MARGIN = 0.05  # 5 % whitespace padding on each side
    if align_axes and n_rows > 0 and n_cols > 0:
        # Align x-axis for each column using the actual data range across all rows
        for col_idx in range(n_cols):
            all_x = []
            for row_idx in range(n_rows):
                xs, _ys = subplot_data_ranges.get((row_idx, col_idx), ([], []))
                all_x.extend(xs)
            if all_x:
                x_span = max(all_x) - min(all_x)
                pad = x_span * AXIS_MARGIN if x_span else 1
                unified_xlim = (min(all_x) - pad, max(all_x) + pad)
                for row_idx in range(n_rows):
                    axes[row_idx][col_idx].set_xlim(unified_xlim)

        # Align y-axis for each row using the actual data range across all columns
        for row_idx in range(n_rows):
            all_y = []
            for col_idx in range(n_cols):
                _xs, ys = subplot_data_ranges.get((row_idx, col_idx), ([], []))
                all_y.extend(ys)
            if all_y:
                y_span = max(all_y) - min(all_y)
                pad = y_span * AXIS_MARGIN if y_span else 1
                unified_ylim = (min(all_y) - pad, max(all_y) + pad)
                for col_idx in range(n_cols):
                    axes[row_idx][col_idx].set_ylim(unified_ylim)
    
    fig.tight_layout()

    if out_file:
        fig.savefig(out_file, bbox_inches='tight')
        print(f"Saved plot to {out_file}")

    return fig


def main():
    parser = argparse.ArgumentParser(description='Generic XY curve plotter for log data')
    parser.add_argument('logfile', help='Log file to parse')
    parser.add_argument('--out', '-o', help='Output file (PNG, SVG, PDF, etc. - format determined by extension)')
    parser.add_argument('--no-show', action='store_true', help="Don't display interactive window")
    parser.add_argument('--no-align-axes', action='store_true', help="Don't align axes for subplots in same column/row")
    parser.add_argument('--histo', action='store_true', help='Also plot normalized histograms of Y values in a separate figure')

    args = parser.parse_args()

    path = Path(args.logfile)
    if not path.exists():
        print(f"Log file not found: {path}", file=sys.stderr)
        sys.exit(1)

    # ticks_mode removed
    data = parse_log(path)

    # if not data['time_ms']:
    #     print('No matching [A] lines found in log.', file=sys.stderr)
    #     sys.exit(1)

    # Always plot the XY curves
    fig_xy = plot_data(data, out_file=args.out, show=False, align_axes=not args.no_align_axes)
    
    # If histo flag is set, also plot histograms in a separate figure
    if args.histo:
        # Modify output filename for histogram if provided
        histo_out_file = None
        if args.out:
            base_name = args.out.rsplit('.', 1)[0]
            ext = args.out.rsplit('.', 1)[1] if '.' in args.out else 'png'
            histo_out_file = f"{base_name}_histo.{ext}"
        plot_histograms(data, out_file=histo_out_file, show=False)

    # Show all figures: fork so child blocks on the GUI and parent returns to shell
    if not args.no_show:
        pid = os.fork()
        if pid == 0:
            # Child process: run the GUI event loop blocking until all figures are closed
            plt.show(block=True)
            os._exit(0)
        # Parent falls through and exits, returning control to the terminal


if __name__ == '__main__':
    main()
